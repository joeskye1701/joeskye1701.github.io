{"pages":[{"title":"Joe","text":"时间就是金钱，效率就是生命。 联系方式 Email：joeskye1701@163.com 微信号：JavaUncle","link":"/about/index.html"},{"title":"归档","text":"","link":"/archives/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hello-world/"},{"title":"JDK1.6 SynchronousQueue","text":"1 介绍 2 源码分析 SynchronousQueue#Transferer SynchronousQueue#TransferStack 伪栈实现 SynchronousQueue#TransferStack#transfer() SynchronousQueue#TransferStack#snode() SynchronousQueue#TransferStack#awaitFulfill() SynchronousQueue#TransferStack#shouldSpin() SynchronousQueue自选参数 SynchronousQueue#TransferStack#clean() SynchronousQueue#TransferQueue 伪队列 SynchronousQueue#TransferQueue#transfer() SynchronousQueue#TransferQueue#advanceHead() SynchronousQueue#TransferQueue#advanceTail() SynchronousQueue#TransferQueue#awaitFulfill() SynchronousQueue#TransferQueue#clean() SynchronousQueue SynchronousQueue 序列化 总结 1 介绍 SynchronousQueue是一种特殊的阻塞队列，它本身没有容量，只有当一个线程从队列取数据的同时，另一个线程才能放一个数据到队列中，反之亦然。存取过程相当于一个线程把数据(安全的)交给另一个线程的过程。 SynchronousQueue也支持公平和非公平模式。 2 源码分析SynchronousQueue内部采用伪栈和伪队列来实现，分别对应非公平模式和公平模式。 SynchronousQueue#Transferer123456789101112131415161718192021/** * Shared internal API for dual stacks and queues. */// 1static abstract class Transferer { /** * Performs a put or take. * * @param e if non-null, the item to be handed to a consumer; * if null, requests that transfer return an item * offered by producer. // 2 * @param timed if this operation should timeout * @param nanos the timeout, in nanoseconds * @return if non-null, the item provided or received; if null, * the operation failed due to timeout or interrupt -- * the caller can distinguish which of these occurred * by checking Thread.interrupted. */ abstract Object transfer(Object e, boolean timed, long nanos);} 伪栈和伪队列的公共基类。标注代码分析 转移数据的方法，用来实现put或者take。 如果不为null，相当于将一个数据交给消费者；如果为null，相当于从一个生产者接收一个消费者交出的数据。 SynchronousQueue#TransferStack 伪栈实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** Dual stack */ static final class TransferStack extends Transferer { /* * This extends Scherer-Scott dual stack algorithm, differing, * among other ways, by using \"covering\" nodes rather than * bit-marked pointers: Fulfilling operations push on marker * nodes (with FULFILLING bit set in mode) to reserve a spot * to match a waiting node. */ /* Modes for SNodes, ORed together in node fields */ /** Node represents an unfulfilled consumer */ // 1 static final int REQUEST = 0; /** Node represents an unfulfilled producer */ // 2 static final int DATA = 1; /** Node is fulfilling another unfulfilled DATA or REQUEST */ // 3 static final int FULFILLING = 2; /** Return true if m has fulfilling bit set */ // 4 static boolean isFulfilling(int m) { return (m &amp; FULFILLING) != 0; } /** Node class for TransferStacks. */ static final class SNode { // 5 volatile SNode next; // next node in stack // 6 volatile SNode match; // the node matched to this volatile Thread waiter; // to control park/unpark Object item; // data; or null for REQUESTs int mode; // Note: item and mode fields don't need to be volatile // since they are always written before, and read after, // other volatile/atomic operations. // 7 SNode(Object item) { this.item = item; } static final AtomicReferenceFieldUpdater&lt;SNode, SNode&gt; nextUpdater = AtomicReferenceFieldUpdater.newUpdater (SNode.class, SNode.class, \"next\"); boolean casNext(SNode cmp, SNode val) { return (cmp == next &amp;&amp; nextUpdater.compareAndSet(this, cmp, val)); } static final AtomicReferenceFieldUpdater&lt;SNode, SNode&gt; matchUpdater = AtomicReferenceFieldUpdater.newUpdater (SNode.class, SNode.class, \"match\"); /** * Tries to match node s to this node, if so, waking up thread. * Fulfillers call tryMatch to identify their waiters. * Waiters block until they have been matched. * * @param s the node to match * @return true if successfully matched to s */ // 8 boolean tryMatch(SNode s) { if (match == null &amp;&amp; matchUpdater.compareAndSet(this, null, s)) { // 9 Thread w = waiter; if (w != null) { // waiters need at most one unpark waiter = null; LockSupport.unpark(w); } return true; } // 10 return match == s; } /** * Tries to cancel a wait by matching node to itself. */ // 11 void tryCancel() { matchUpdater.compareAndSet(this, null, this); } boolean isCancelled() { return match == this; } } /** The head (top) of the stack */ volatile SNode head; static final AtomicReferenceFieldUpdater&lt;TransferStack, SNode&gt; headUpdater = AtomicReferenceFieldUpdater.newUpdater (TransferStack.class, SNode.class, \"head\"); boolean casHead(SNode h, SNode nh) { return h == head &amp;&amp; headUpdater.compareAndSet(this, h, nh); } .... TransferStack是伪栈实现。标注代码分析 一个没有得到数据的消费者。 一个没有交出数据的生产者。 匹配另一个生产者或者消费者。 判断是否包含正在匹配(FULFILLING)的标记。 栈中的下一个节点。 和当前节点完成匹配的节点。 item和mode不需要volatile修饰；是因为它们在其他的volatile/atomic操作之前写，之后读。（HB关系） 尝试匹配节点s和当前节点，如果匹配成功，唤醒等待线程。(向消费者传递数据或向生产者获取数据)调用tryMatch()来确定它们的等待线程，然后唤醒这个等待线程。 如果当前节点的match为空，那么CAS设置s为match，然后唤醒waiter。 如果match不为null，或者CAS设置match失败，那么比较match和s是否为相同对象。如果相同，说明已经完成匹配，匹配成功。 尝试取消当前节点(有线程等待)，通过将match设置为自身。 SynchronousQueue#TransferStack#transfer()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * Puts or takes an item. */ Object transfer(Object e, boolean timed, long nanos) { /* * Basic algorithm is to loop trying one of three actions: * * 1. If apparently empty or already containing nodes of same * mode, try to push node on stack and wait for a match, * returning it, or null if cancelled. * * 2. If apparently containing node of complementary mode, * try to push a fulfilling node on to stack, match * with corresponding waiting node, pop both from * stack, and return matched item. The matching or * unlinking might not actually be necessary because of * other threads performing action 3: * * 3. If top of stack already holds another fulfilling node, * help it out by doing its match and/or pop * operations, and then continue. The code for helping * is essentially the same as for fulfilling, except * that it doesn't return the item. */ // 1 SNode s = null; // constructed/reused as needed int mode = (e == null)? REQUEST : DATA; for (;;) { SNode h = head; // 2 if (h == null || h.mode == mode) { // empty or same-mode // 3 if (timed &amp;&amp; nanos &lt;= 0) { // can't wait if (h != null &amp;&amp; h.isCancelled()) // 4 casHead(h, h.next); // pop cancelled node else return null; } else if (casHead(h, s = snode(s, e, h, mode))) {// 5 // 6 SNode m = awaitFulfill(s, timed, nanos); // 7 if (m == s) { // wait was cancelled // 8 clean(s); return null; } // 9 if ((h = head) != null &amp;&amp; h.next == s) // 10 casHead(h, s.next); // help s's fulfiller return mode == REQUEST? m.item : s.item; } } else if (!isFulfilling(h.mode)) { // try to fulfill // 11 // 12 if (h.isCancelled()) // already cancelled // 13 casHead(h, h.next); // pop and retry else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {// 14 for (;;) { // loop until matched or waiters disappear // 15 SNode m = s.next; // m is s's match // 16 if (m == null) { // all waiters are gone // 17 casHead(s, null); // pop fulfill node // 18 s = null; // use new node next time break; // restart main loop } // 19 SNode mn = m.next; // 20 if (m.tryMatch(s)) { // 21 casHead(s, mn); // pop both s and m return (mode == REQUEST)? m.item : s.item; } else // lost match // 22 // 23 s.casNext(m, mn); // help unlink } } } else { // 24 // help a fulfiller // 25 SNode m = h.next; // m is h's match // 26 if (m == null) // waiter is gone casHead(h, null); // pop fulfilling node else { // 27 SNode mn = m.next; // 28 if (m.tryMatch(h)) // help match // 29 casHead(h, mn); // pop both h and m else //30 // lost match // 31 h.casNext(m, mn); // help unlink } } } } 标注代码分析 基本算法是在一个无限循环中尝试下面三种情况里面的一种： 如果当前栈为空或者包含与给定节点模式相同的节点，尝试将节点压入栈内，并等待一个匹配节点，最后返回匹配节点或者null(如果被取消)。 如果当前栈包含于给定节点模式互补的节点，尝试将这个节点打上FULFILLING标记，然后压入栈中，和相应的节点进行匹配，然后将两个节点(当前节点和互补节点)弹出栈，并返回匹配节点的数据。匹配和删除动作不是必须要做的，因为其他线程会执行动作3。 如果栈顶已经存在一个FULFILLING(正在满足其他节点)的节点，帮助这个节点完成匹配和移除(出栈)的操作。然后继续执行(主循环)。这部分代码基本和动作2的代码一样，只是不会返回节点的数据。 head为null或者head和e的mode相同。 超时。 如果h不为null且被取消，弹出h。 创建一个SNode，赋给s，将原本的head节点做为其next节点，并尝试将其设置为新的head。 等待其他线程来满足当前线程。 awaitFulfill方法返回后，判断下是否被取消。 如果取消，清理一下s节点。 因为上面已经将s设置为head，如果满足这个条件说明有其他节点t插入到s前面，变成了head，而且这个t就是和s匹配的节点，他们已经完成匹配。 将s的next节点设置为head。相当于把s和t一起移除了。 如果栈中存在头节点，且和当前节点不是相同模式，那么说明它们是一对儿对等的节点，尝试用当前节点s来满足h节点。 如果h节点已经被取消。 将h节点弹出，并将h节点的next节点设置为栈的head。 尝试将当前节点打上”正在匹配”的标记，并设置为head。 s是当前节点，m是s的next节点，它们是正在匹配的两个节点。 如果m为空，可能其他节点把m匹配走了。 将s弹出。 将s置空，下轮循环的时候还会新建。 获取m的next节点，如果s和m匹配成功，mn就得补上head的位置了。 尝试匹配一下，匹配成功的话会把m上等待的线程唤醒。 如果匹配成功，把s和m弹出。 没匹配成功的话，说明m可能被其他节点满足了。 说明m已经被其他节点匹配了，那就把m移除掉。 说明栈顶的h正在匹配过程中。 m是h的配对儿，h正在和m匹配。 如果m为空，其他节点把m匹配走了。 获取m的next节点，如果m和h匹配成功，mn就得补上head的位置了。 匹配一下m和h。 匹配成功的话，把h和m弹出。 没匹配成功的话，说明m可能被其他节点满足了。 没成功的话，说明m已经被其他节点匹配了，那就把m移除掉。 SynchronousQueue#TransferStack#snode()12345678910111213/** * Creates or resets fields of a node. Called only from transfer * where the node to push on stack is lazily created and * reused when possible to help reduce intervals between reads * and CASes of head and to avoid surges of garbage when CASes * to push nodes fail due to contention. */static SNode snode(SNode s, Object e, SNode next, int mode) { if (s == null) s = new SNode(e); s.mode = mode; s.next = next; return s;} SynchronousQueue#TransferStack#awaitFulfill()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Spins/blocks until node s is matched by a fulfill operation. * * @param s the waiting node * @param timed true if timed wait * @param nanos timeout value * @return matched node, or s if cancelled */ // 1SNode awaitFulfill(SNode s, boolean timed, long nanos) { /* * When a node/thread is about to block, it sets its waiter * field and then rechecks state at least one more time * before actually parking, thus covering race vs * fulfiller noticing that waiter is non-null so should be * woken. * * When invoked by nodes that appear at the point of call * to be at the head of the stack, calls to park are * preceded by spins to avoid blocking when producers and * consumers are arriving very close in time. This can * happen enough to bother only on multiprocessors. * * The order of checks for returning out of main loop * reflects fact that interrupts have precedence over * normal returns, which have precedence over * timeouts. (So, on timeout, one last check for match is * done before giving up.) Except that calls from untimed * SynchronousQueue.{poll/offer} don't check interrupts * and don't wait at all, so are trapped in transfer * method rather than calling awaitFulfill. */ long lastTime = (timed)? System.nanoTime() : 0; Thread w = Thread.currentThread(); SNode h = head; int spins = (shouldSpin(s)? (timed? maxTimedSpins : maxUntimedSpins) : 0); for (;;) { if (w.isInterrupted()) // 2 s.tryCancel(); SNode m = s.match; if (m != null) // 3 return m; if (timed) { long now = System.nanoTime(); nanos -= now - lastTime; lastTime = now; if (nanos &lt;= 0) { // 4 s.tryCancel(); continue; } } if (spins &gt; 0) // 5 spins = shouldSpin(s)? (spins-1) : 0; else if (s.waiter == null) // 6 s.waiter = w; // establish waiter so can park next iter else if (!timed) LockSupport.park(this); else if (nanos &gt; spinForTimeoutThreshold) // 7 LockSupport.parkNanos(this, nanos); }} 标注代码分析 自旋/阻塞直到节点被匹配。 如果当前线程被中断了，那么取消当前节点。 如果已经匹配成功，就返回匹配的节点。 如果超时，也取消当前节点。 自旋控制，每次循环都检测是否满足自旋条件，满足的话，自旋值就减去1，然后进入下次循环(一直减到0) 第一次循环时，会将当前线程设置到s上。 有超时条件下，会检测超时时间是否大于超时阀值(这应该是一个经验值)，大于就阻塞，小于就自旋。 在s节点真正阻塞之前，将当前线程设置到s上面，然后检查中断状态(不少于一次)，以确保后续和s匹配的节点来唤醒当前线程。当执行此方法时，如果执行节点恰好在栈顶，阻塞之前会做一些自旋，为的是如果有生产者或消费者马上到来，就不需要执行节点阻塞了。这种优化在多核下是有意义的。 SynchronousQueue#TransferStack#shouldSpin()123456789/** * Returns true if node s is at head or there is an active * fulfiller. */// 1boolean shouldSpin(SNode s) { SNode h = head; return (h == s || h == null || isFulfilling(h.mode));} 标注代码分析 如果s节点就是当前栈中头节点，或者头节点正在匹配过程中，那么可以自旋一下。 SynchronousQueue自选参数123456789101112131415161718192021222324/** The number of CPUs, for spin control */ static final int NCPUS = Runtime.getRuntime().availableProcessors(); /** * The number of times to spin before blocking in timed waits. * The value is empirically derived -- it works well across a * variety of processors and OSes. Empirically, the best value * seems not to vary with number of CPUs (beyond 2) so is just * a constant. */ static final int maxTimedSpins = (NCPUS &lt; 2)? 0 : 32; /** * The number of times to spin before blocking in untimed waits. * This is greater than timed value because untimed waits spin * faster since they don't need to check times on each spin. */ static final int maxUntimedSpins = maxTimedSpins * 16; /** * The number of nanoseconds for which it is faster to spin * rather than to use timed park. A rough estimate suffices. */ static final long spinForTimeoutThreshold = 1000L; SynchronousQueue#TransferStack#clean()123456789101112131415161718192021222324252627282930313233343536373839/** * Unlinks s from the stack. */// 1void clean(SNode s) { s.item = null; // forget item s.waiter = null; // forget thread /* * At worst we may need to traverse entire stack to unlink * s. If there are multiple concurrent calls to clean, we * might not see s if another thread has already removed * it. But we can stop when we see any node known to * follow s. We use s.next unless it too is cancelled, in * which case we try the node one past. We don't check any * further because we don't want to doubly traverse just to * find sentinel. */ SNode past = s.next; if (past != null &amp;&amp; past.isCancelled()) past = past.next; // Absorb cancelled nodes at head // 2 SNode p; while ((p = head) != null &amp;&amp; p != past &amp;&amp; p.isCancelled()) casHead(p, p.next); // Unsplice embedded nodes // 3 while (p != null &amp;&amp; p != past) { SNode n = p.next; if (n != null &amp;&amp; n.isCancelled()) p.casNext(n, n.next); else p = n; }} 标注代码分析 当s节点被取消时，才会调用这个方法。 将从栈顶节点开始到past的连续的取消节点移除。 如果p本身未取消(上面的while碰到一个未取消的节点就会退出，但这个节点和past节点之间可能还有取消节点)，再把p到past之间的取消节点都移除。 SynchronousQueue#TransferQueue 伪队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** Dual Queue */ static final class TransferQueue extends Transferer { /* * This extends Scherer-Scott dual queue algorithm, differing, * among other ways, by using modes within nodes rather than * marked pointers. The algorithm is a little simpler than * that for stacks because fulfillers do not need explicit * nodes, and matching is done by CAS'ing QNode.item field * from non-null to null (for put) or vice versa (for take). */ /** Node class for TransferQueue. */ static final class QNode { volatile QNode next; // next node in queue volatile Object item; // CAS'ed to or from null volatile Thread waiter; // to control park/unpark final boolean isData; QNode(Object item, boolean isData) { this.item = item; this.isData = isData; } static final AtomicReferenceFieldUpdater&lt;QNode, QNode&gt; nextUpdater = AtomicReferenceFieldUpdater.newUpdater (QNode.class, QNode.class, \"next\"); boolean casNext(QNode cmp, QNode val) { return (next == cmp &amp;&amp; nextUpdater.compareAndSet(this, cmp, val)); } static final AtomicReferenceFieldUpdater&lt;QNode, Object&gt; itemUpdater = AtomicReferenceFieldUpdater.newUpdater (QNode.class, Object.class, \"item\"); boolean casItem(Object cmp, Object val) { return (item == cmp &amp;&amp; itemUpdater.compareAndSet(this, cmp, val)); } /** * Tries to cancel by CAS'ing ref to this as item. */ // 1 void tryCancel(Object cmp) { itemUpdater.compareAndSet(this, cmp, this); } boolean isCancelled() { return item == this; } /** * Returns true if this node is known to be off the queue * because its next pointer has been forgotten due to * an advanceHead operation. */ // 2 boolean isOffList() { return next == this; } } /** Head of queue */ // 3 transient volatile QNode head; /** Tail of queue */ // 4 transient volatile QNode tail; /** * Reference to a cancelled node that might not yet have been * unlinked from queue because it was the last inserted node * when it cancelled. */ // 5 transient volatile QNode cleanMe; TransferQueue() { // 6 QNode h = new QNode(null, false); // initialize to dummy node. head = h; tail = h; } 标注代码分析 尝试取消节点。取消就是将节点的item域指向自身。 判断节点是否离开了队列。 队列头节点。 队列尾节点。 指向一个被取消的节点，如果取消这个节点时，它是最后一个进入队列的节点，那么这个节点可能还没有离开队列。 初始化一个哨兵节点。 SynchronousQueue#TransferQueue#transfer()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * Puts or takes an item. */ Object transfer(Object e, boolean timed, long nanos) { /* Basic algorithm is to loop trying to take either of * two actions: * * 1. If queue apparently empty or holding same-mode nodes, * try to add node to queue of waiters, wait to be * fulfilled (or cancelled) and return matching item. * * 2. If queue apparently contains waiting items, and this * call is of complementary mode, try to fulfill by CAS'ing * item field of waiting node and dequeuing it, and then * returning matching item. * * In each case, along the way, check for and try to help * advance head and tail on behalf of other stalled/slow * threads. * * The loop starts off with a null check guarding against * seeing uninitialized head or tail values. This never * happens in current SynchronousQueue, but could if * callers held non-volatile/final ref to the * transferer. The check is here anyway because it places * null checks at top of loop, which is usually faster * than having them implicitly interspersed. */ QNode s = null; // constructed/reused as needed boolean isData = (e != null); for (;;) { QNode t = tail; QNode h = head; // 1 if (t == null || h == null) // saw uninitialized value continue; // spin // 2 if (h == t || t.isData == isData) { // empty or same-mode QNode tn = t.next; // 3 if (t != tail) // inconsistent read continue; // 4 if (tn != null) { // lagging tail // 5 advanceTail(t, tn); continue; } // 6 if (timed &amp;&amp; nanos &lt;= 0) // can't wait return null; if (s == null) // 7 s = new QNode(e, isData); // 8 if (!t.casNext(null, s)) // failed to link in continue; // 9 advanceTail(t, s); // swing tail and wait // 10 Object x = awaitFulfill(s, e, timed, nanos); // 11 if (x == s) { // wait was cancelled // 12 clean(t, s); return null; } // 13 if (!s.isOffList()) { // not already unlinked // 14 advanceHead(t, s); // unlink if head if (x != null) // and forget fields s.item = s; s.waiter = null; } return (x != null)? x : e; } else { // complementary-mode // 15 QNode m = h.next; // node to fulfill // 16 if (t != tail || m == null || h != head) continue; // inconsistent read Object x = m.item; // 17 if (isData == (x != null) || // m already fulfilled x == m || // m cancelled !m.casItem(x, e)) { // lost CAS // 18 advanceHead(h, m); // dequeue and retry continue; } // 19 advanceHead(h, m); // successfully fulfilled // 20 LockSupport.unpark(m.waiter); return (x != null)? x : e; } } } 标注代码分析 如果看到未初始化的头尾节点。 队列为空或者当前节点和队列中节点模式相同。 读取到不一致的结果，说明同时有其他线程修改了tail。 说明其他线程已经添加了新节点tn，但还没将其设置为tail。 当前线程帮忙推进尾节点，就是尝试将tn设置为尾节点。 超时。 初始化s。 尝试将当前节点s拼接到t后面。 尝试将s设置为队列尾节点。 然后等着被匹配。 如果被取消。 清理s节点。 如果s节点还没有离开队列。 尝试将s设置为头节点，移除t。 找到能匹配的节点。 读取到不一致的结果，进入下一轮循环。 如果m已经被匹配；或者m被取消；如果尝试将数据e设置到m上失败。 将h出队，m设置为头结点，然后重试。 成功匹配，推进头节点。 唤醒m上的等待线程。 基本算法是在一个无限循环中尝试下面两种动作里面的一种： 如果队列为空，或者包含相同模式(存或者取)的节点。 尝试将节点加入等待的队列，直到被匹配(或被取消)， 同时返回匹配节点的数据。 如果队列中包含等待的节点，并且当前节点和这个等待节点能相互匹配，那么尝试匹配等待节点并将这个节点出队，然后返回匹配节点的数据。 在每个动作里面，都会检测并帮助其他线程来完成节点推进。在循环开始的时候会做一个非空检测，以避免当前线程看到未初始化的头尾节点。这种情况在当前SynchronousQueue中永远不会发生，但如果调用者持有一个非volatile/final域的话，就有可能会发生。在循环开始的时间做这个非空检测要比在内部(分支里)做性能好一些。 SynchronousQueue#TransferQueue#advanceHead()12345678/** * Tries to cas nh as new head; if successful, unlink * old head's next node to avoid garbage retention. */void advanceHead(QNode h, QNode nh) { if (h == head &amp;&amp; headUpdater.compareAndSet(this, h, nh)) h.next = h; // forget old next} SynchronousQueue#TransferQueue#advanceTail()1234567/** * Tries to cas nt as new tail. */ void advanceTail(QNode t, QNode nt) { if (tail == t) tailUpdater.compareAndSet(this, t, nt); } SynchronousQueue#TransferQueue#awaitFulfill()12345678910111213141516171819202122232425262728293031323334353637383940/** * Spins/blocks until node s is fulfilled. * * @param s the waiting node * @param e the comparison value for checking match * @param timed true if timed wait * @param nanos timeout value * @return matched item, or s if cancelled */ Object awaitFulfill(QNode s, Object e, boolean timed, long nanos) { /* Same idea as TransferStack.awaitFulfill */ long lastTime = (timed)? System.nanoTime() : 0; Thread w = Thread.currentThread(); int spins = ((head.next == s) ? (timed? maxTimedSpins : maxUntimedSpins) : 0); for (;;) { if (w.isInterrupted()) s.tryCancel(e); Object x = s.item; if (x != e) return x; if (timed) { long now = System.nanoTime(); nanos -= now - lastTime; lastTime = now; if (nanos &lt;= 0) { s.tryCancel(e); continue; } } if (spins &gt; 0) --spins; else if (s.waiter == null) s.waiter = w; else if (!timed) LockSupport.park(this); else if (nanos &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanos); } } SynchronousQueue#TransferQueue#clean()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 /** * Gets rid of cancelled node s with original predecessor pred. */ void clean(QNode pred, QNode s) { s.waiter = null; // forget thread /* * At any given time, exactly one node on list cannot be * deleted -- the last inserted node. To accommodate this, * if we cannot delete s, we save its predecessor as * \"cleanMe\", deleting the previously saved version * first. At least one of node s or the node previously * saved can always be deleted, so this always terminates. */ // 1 while (pred.next == s) { // Return early if already unlinked QNode h = head; QNode hn = h.next; // Absorb cancelled first node as head if (hn != null &amp;&amp; hn.isCancelled()) { // 2 advanceHead(h, hn); continue; }QNode t = tail; // Ensure consistent read for tail // 3 if (t == h) return;QNode tn = t.next; // 4if (t != tail) continue; if (tn != null) { // 5 advanceTail(t, tn); continue; } // 6 if (s != t) { // If not tail, try to unsplice QNode sn = s.next; // 7 if (sn == s || pred.casNext(s, sn)) return; } // 8 QNode dp = cleanMe; // 9 if (dp != null) { // Try unlinking previous cancelled node QNode d = dp.next; QNode dn; if (d == null || // d is gone or d == dp || // d is off list or !d.isCancelled() || // d not cancelled or (d != t &amp;&amp; // d not tail and (dn = d.next) != null &amp;&amp; // has successor dn != d &amp;&amp; // that is on list dp.casNext(d, dn)))// 10 // d unspliced casCleanMe(dp, null); // 11 if (dp == pred) return; // s is already saved node } else if (casCleanMe(null, pred)) // 12 return; // Postpone cleaning s } } 标注代码分析 在任意给定的时间点，能删除的节点一定是最后入队的节点。为了满足这个条件，如果当前无法删除s，就将其前驱节点保存为”cleanMe”，先删除之前保存的版本。至少节点s和之前保存的节点里面有一个能被删除，所以方法一定会结束。 如果head节点的next节点被取消，那么推进一下head节点。 如果队列为空。 出现不一致读，重试。 帮助推进尾节点。 如果s不是尾节点，移除s。 如果s已经被移除退出循环，否则尝试断开s。 下面要做的事情大体就是：如果s是位节点，那么不会马上删除s，而是将s的前驱节点设置为cleanMe，下次清理其他取消节点的时候会顺便把s移除。 如果dp不为null，说明是前一个被取消节点，将其移除。 把之前标记为cleanMe节点的next节点d移除。 说明s的前驱已经是cleanMe了(后续会被删掉)。 如果当前cleanMe为null，那么将s前驱节点设置为cleanMe，并退出。 SynchronousQueue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * The transferer. Set only in constructor, but cannot be declared * as final without further complicating serialization. Since * this is accessed only at most once per public method, there * isn't a noticeable performance penalty for using volatile * instead of final here. */ private transient volatile Transferer transferer; /** * Creates a &lt;tt&gt;SynchronousQueue&lt;/tt&gt; with nonfair access policy. */ public SynchronousQueue() { this(false); } /** * Creates a &lt;tt&gt;SynchronousQueue&lt;/tt&gt; with the specified fairness policy. * * @param fair if true, waiting threads contend in FIFO order for * access; otherwise the order is unspecified. */ public SynchronousQueue(boolean fair) { transferer = (fair)? new TransferQueue() : new TransferStack(); } /** * Adds the specified element to this queue, waiting if necessary for * another thread to receive it. * * @throws InterruptedException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ // 1 public void put(E o) throws InterruptedException { if (o == null) throw new NullPointerException(); if (transferer.transfer(o, false, 0) == null) { Thread.interrupted(); throw new InterruptedException(); } } /** * Inserts the specified element into this queue, waiting if necessary * up to the specified wait time for another thread to receive it. * * @return &lt;tt&gt;true&lt;/tt&gt; if successful, or &lt;tt&gt;false&lt;/tt&gt; if the * specified waiting time elapses before a consumer appears. * @throws InterruptedException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ // 2 public boolean offer(E o, long timeout, TimeUnit unit) throws InterruptedException { if (o == null) throw new NullPointerException(); if (transferer.transfer(o, true, unit.toNanos(timeout)) != null) return true; if (!Thread.interrupted()) return false; throw new InterruptedException(); } /** * Inserts the specified element into this queue, if another thread is * waiting to receive it. * * @param e the element to add * @return &lt;tt&gt;true&lt;/tt&gt; if the element was added to this queue, else * &lt;tt&gt;false&lt;/tt&gt; * @throws NullPointerException if the specified element is null */ // 3 public boolean offer(E e) { if (e == null) throw new NullPointerException(); return transferer.transfer(e, true, 0) != null; } /** * Retrieves and removes the head of this queue, waiting if necessary * for another thread to insert it. * * @return the head of this queue * @throws InterruptedException {@inheritDoc} */ // 4 public E take() throws InterruptedException { Object e = transferer.transfer(null, false, 0); if (e != null) return (E)e; Thread.interrupted(); throw new InterruptedException(); } /** * Retrieves and removes the head of this queue, waiting * if necessary up to the specified wait time, for another thread * to insert it. * * @return the head of this queue, or &lt;tt&gt;null&lt;/tt&gt; if the * specified waiting time elapses before an element is present. * @throws InterruptedException {@inheritDoc} */ // 5 public E poll(long timeout, TimeUnit unit) throws InterruptedException { Object e = transferer.transfer(null, true, unit.toNanos(timeout)); if (e != null || !Thread.interrupted()) return (E)e; throw new InterruptedException(); } /** * Retrieves and removes the head of this queue, if another thread * is currently making an element available. * * @return the head of this queue, or &lt;tt&gt;null&lt;/tt&gt; if no * element is available. */ // 6 public E poll() { return (E)transferer.transfer(null, true, 0); } 标注代码分析 添加一个数据到队列，等到其他线程接收这个数据。 添加一个数据到队列，等到其他线程接收这个数据或者超时。 添加一个数据到队列，如果有其他线程正等待接收这个数据且接收成功，返回true；否则返回false。这个方法不阻塞。 获取并移除队列前端的数据，如果队列中没有数据，就等待其他线程添加一个数据。 获取并移除队列前端的数据，如果队列中没有数据，就等待其他线程添加一个数据或者超时。 如果其他线程正在添加数据到队列，那么尝试获取并移除这个数据。这个方法不阻塞。 SynchronousQueue 序列化序列化比较特别，因为transferer域本身不需要序列化，但需要记住transferer是内部伪栈和伪队列。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * To cope with serialization strategy in the 1.5 version of * SynchronousQueue, we declare some unused classes and fields * that exist solely to enable serializability across versions. * These fields are never used, so are initialized only if this * object is ever serialized or deserialized. */ static class WaitQueue implements java.io.Serializable { } static class LifoWaitQueue extends WaitQueue { private static final long serialVersionUID = -3633113410248163686L; } static class FifoWaitQueue extends WaitQueue { private static final long serialVersionUID = -3623113410248163686L; } private ReentrantLock qlock; private WaitQueue waitingProducers; private WaitQueue waitingConsumers; /** * Save the state to a stream (that is, serialize it). * * @param s the stream */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // 1 boolean fair = transferer instanceof TransferQueue; if (fair) { qlock = new ReentrantLock(true); waitingProducers = new FifoWaitQueue(); waitingConsumers = new FifoWaitQueue(); } else { qlock = new ReentrantLock(); waitingProducers = new LifoWaitQueue(); waitingConsumers = new LifoWaitQueue(); } s.defaultWriteObject(); } private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); if (waitingProducers instanceof FifoWaitQueue) transferer = new TransferQueue(); else transferer = new TransferStack(); } 标注代码分析 序列化时根据TransferQueue类型来创建WaitQueue实例。 总结伪栈的结构下，新来的线程会作为栈顶节点或者优先和栈顶的等待节点进行匹配，并不是公平的；但伪队列的结构下，新来的线程会在队尾，或者和队头的等待节点(最前到的)进行匹配，能够保证一定的公平性。","link":"/JDK1.6 SynchronousQueue/"}],"tags":[{"name":"JDK6 源码","slug":"JDK6-源码","link":"/tags/JDK6-源码/"}],"categories":[{"name":"JDK6 源码","slug":"JDK6-源码","link":"/categories/JDK6-源码/"}]}